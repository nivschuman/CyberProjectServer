<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PasswordManager API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PasswordManager</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from Server import CommunicationProtocolServer
import pyodbc
import json
import base64
from Crypto.Cipher import PKCS1_v1_5
from Crypto.PublicKey import RSA
from random import randbytes


class PasswordManagerServer:
    &#34;&#34;&#34;
    A server for managing user passwords with various functionalities such as user creation, login,
    retrieving and setting passwords, and deleting users.

    Attributes:
        server (CommunicationProtocolServer): The communication protocol server instance.
        db_connection (pyodbc.Connection): The database connection.
    &#34;&#34;&#34;

    def __init__(self, host, port, db_connection_string, with_ssl):
        &#34;&#34;&#34;
        Constructor:
            Initializes the PasswordManagerServer with the specified parameters.

            Args:
                host (str): The host address.
                port (int): The port number.
                db_connection_string (str): The database connection string.
                with_ssl (bool): Whether to use SSL.
        &#34;&#34;&#34;

        self.server = CommunicationProtocolServer(host, port, 10800, with_ssl)  # session ttl is 3 hours
        self.db_connection = pyodbc.connect(db_connection_string)

        self.server.handle_method(&#34;create_user&#34;, self.create_user)
        self.server.handle_method(&#34;login_request&#34;, self.login_request)
        self.server.handle_method(&#34;login_test&#34;, self.login_test)
        self.server.handle_method(&#34;get_sources&#34;, self.get_sources)
        self.server.handle_method(&#34;get_password&#34;, self.get_password)
        self.server.handle_method(&#34;set_password&#34;, self.set_password)
        self.server.handle_method(&#34;delete_password&#34;, self.delete_password)
        self.server.handle_method(&#34;delete_user&#34;, self.delete_user)

    def start_server(self):
        &#34;&#34;&#34;
        Starts the server to listen for incoming requests.
        &#34;&#34;&#34;

        self.server.serve_forever()

    # receive json with publicKey, userName and create such user
    # returns ascii with info on success or error
    def create_user(self, req, res, session):
        &#34;&#34;&#34;
        Creates a new user with the provided public key and username.

        Args:
            req (CommunicationProtocol): The request message.
            res (CommunicationProtocol): The response message.
            session (Session): The current session.

        The request body should contain a JSON object with the following keys:
            - publicKey (str): The user&#39;s public key, encoded in base64.
            - userName (str): The username.

        The response body will contain an ASCII string indicating success or error.
        &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        body_str = req.body.decode(&#34;ascii&#34;)
        body_json = json.loads(body_str)

        public_key_bytes = base64.b64decode(body_json[&#34;publicKey&#34;])
        user_name = body_json[&#34;userName&#34;]

        try:
            # check if there already exists a user with given username
            public_key_str = f&#34;0x{public_key_bytes.hex()}&#34;
            db_cursor.execute(f&#34;SELECT UserName, PublicKey FROM Users WHERE UserName=?&#34;, user_name)
            user_with_same_username = len(db_cursor.fetchall()) != 0
            db_cursor.execute(f&#34;SELECT UserName, PublicKey FROM Users WHERE PublicKey=?&#34;, public_key_str)
            user_with_same_public_key = len(db_cursor.fetchall()) != 0

            if user_with_same_username:
                res.body = &#34;User with this username already exists, choose a different username&#34;.encode(&#34;ascii&#34;)
            elif user_with_same_public_key:
                res.body = &#34;User with this public key already exists, choose a different public key&#34;.encode(&#34;ascii&#34;)
            else:
                db_cursor.execute(f&#34;INSERT INTO Users (UserName, PublicKey) VALUES (?, CONVERT(VARBINARY(300),?,1))&#34;, user_name, public_key_str)
                db_cursor.commit()
                res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)

            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;create_user&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
        except pyodbc.Error as db_error:
            print(db_error)
            sql_state = db_error.args[0]
            sql_error_message = db_error.args[1]
            res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;create_user&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)

    # receive username in ascii and return encrypted random 64 bits, no body is returned on error
    def login_request(self, req, res, session):
        &#34;&#34;&#34;
        Handles a login request by returning an encrypted random 64-bit number.

        Args:
            req (CommunicationProtocol): The request message.
            res (CommunicationProtocol): The response message.
            session (Session): The current session.

        The request body should contain the username as an ASCII string.

        The response body will contain the encrypted random 64-bit number, or no body if there is an error.
        &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        user_name = req.body.decode(&#34;ascii&#34;)

        # get user&#39;s public key from database
        public_key_bytes = None
        try:
            db_cursor.execute(f&#34;SELECT PublicKey FROM Users WHERE UserName=?&#34;, user_name)
            public_key_bytes = db_cursor.fetchall()
        except pyodbc.Error as db_error:
            print(db_error)
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;login_request&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;bytes&#34;)
            return

        # user does not exists or this was called without a session
        if len(public_key_bytes) == 0 or session is None:
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
        else:
            public_key_bytes = public_key_bytes[0][0]
            rsa_key = RSA.importKey(public_key_bytes)
            cipher = PKCS1_v1_5.new(rsa_key)

            # generate random 64 bit number and encrypt it
            random_number = randbytes(8)
            random_number_encrypted = cipher.encrypt(random_number)

            # return number in body
            res.body = random_number_encrypted
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))

            # store number in session and user name
            session.data[&#34;loginNumber&#34;] = random_number
            session.data[&#34;loginUserName&#34;] = user_name

        res.set_header_value(&#34;Method&#34;, &#34;login_request&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;bytes&#34;)

    # receive decrypted 64 bits and if they match bits in session store logged in uid
    # returns ascii with info for success or failure
    def login_test(self, req, res, session):
        &#34;&#34;&#34;
        Tests the login by verifying the decrypted 64-bit number.

        Args:
            req (CommunicationProtocol): The request message.
            res (CommunicationProtocol): The response message.
            session (Session): The current session.

        The request body should contain the decrypted 64-bit number as bytes.

        The response body will contain an ASCII string indicating success or failure.
        &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        decrypted_number_bytes = req.body

        if session is None:
            res.body = &#34;Failed - no session&#34;.encode(&#34;ascii&#34;)
        elif session.data.get(&#34;loginNumber&#34;) is None:
            res.body = &#34;Failed - no login number in session&#34;.encode(&#34;ascii&#34;)
        elif session.data.get(&#34;loginUserName&#34;) is None:
            res.body = &#34;Failed - no login username in session&#34;.encode(&#34;ascii&#34;)
        elif decrypted_number_bytes != session.data[&#34;loginNumber&#34;]:
            res.body = &#34;Failed - incorrect number&#34;.encode(&#34;ascii&#34;)
        else:  # correct number and data is in session
            try:
                # get user id from database
                user_name = session.data[&#34;loginUserName&#34;]
                db_cursor.execute(f&#34;SELECT ID FROM Users WHERE UserName=?&#34;, user_name)
                user_id = db_cursor.fetchall()

                if len(user_id) == 0:
                    res.body = f&#34;Failed - user {user_name} doesn&#39;t exist&#34;.encode(&#34;ascii&#34;)
                else:
                    session.data[&#34;loggedInUID&#34;] = user_id[0][0]
                    res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)
            except pyodbc.Error as db_error:
                print(db_error)
                sql_state = db_error.args[0]
                sql_error_message = db_error.args[1]
                res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;

        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;login_test&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)

    # returns json array of all sources tied to user in session. Return no body if error
    def get_sources(self, req, res, session):
        &#34;&#34;&#34;
        Retrieves the sources tied to the logged-in user.

        Args:
            req (CommunicationProtocol): The request message.
            res (CommunicationProtocol): The response message.
            session (Session): The current session.

        The response body will contain a JSON array of sources, or no body if there is an error.
        &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        # no session
        if session is None:
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;get_sources&#34;)

        # user is not logged in
        if session.data.get(&#34;loggedInUID&#34;) is None:
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;get_sources&#34;)
            return

        user_id = session.data[&#34;loggedInUID&#34;]

        # get sources
        sources_db = None
        sources = []
        try:
            db_cursor.execute(f&#34;SELECT Source FROM Passwords WHERE UserID=?&#34;, user_id)
            sources_db = db_cursor.fetchall()
        except pyodbc.Error as db_error:
            print(db_error)
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;get_sources&#34;)
            return

        for source_item in sources_db:
            sources.append(source_item[0])

        sources_json = json.dumps(sources)
        sources_json = sources_json.encode(&#34;ascii&#34;)

        res.body = sources_json
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;get_sources&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii json&#34;)

    # gets ascii string of password source and returns encrypted password, no body if error
    def get_password(self, req, res, session):
        &#34;&#34;&#34;
         Retrieves the password for the specified source for the logged in user.

         Args:
             req (CommunicationProtocol): The request message.
             res (CommunicationProtocol): The response message.
             session (Session): The current session.

         The request body should contain the source as an ASCII string.

         The response body will contain the encrypted password, or no body if there is an error.
         &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        source = req.body.decode(&#34;ascii&#34;)

        # no session
        if session is None:
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
            return

        # user is not logged in
        if session.data.get(&#34;loggedInUID&#34;) is None:
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
            return

        user_id = session.data[&#34;loggedInUID&#34;]

        password = None
        try:
            db_cursor.execute(f&#34;SELECT Password FROM Passwords WHERE UserID=? AND Source=?&#34;, user_id, source)
            password = db_cursor.fetchall()
        except pyodbc.Error as db_error:
            print(db_error)
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
            return

        # no password found
        if len(password) == 0:
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
            return

        password = password[0][0]

        res.body = password
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;bytes&#34;)

    # gets json of source and password encoded in base64, returns ascii if success or failure
    def set_password(self, req, res, session):
        &#34;&#34;&#34;
        Sets the password for a specific source for the logged in user.

        Args:
            req (CommunicationProtocol): The request message.
            res (CommunicationProtocol): The response message.
            session (Session): The current session.

        The request body should contain a JSON object with the following keys:
            - source (str): The source.
            - password (str): The password.

        The response body will contain an ASCII string indicating success or failure.
        &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        body_str = req.body.decode(&#34;ascii&#34;)
        body_json = json.loads(body_str)

        source = body_json[&#34;source&#34;]
        password = base64.b64decode(body_json[&#34;password&#34;])
        password_str = f&#34;0x{password.hex()}&#34;

        # no session
        if session is None:
            res.body = &#34;Failed - no session&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        # user is not logged in
        if session.data.get(&#34;loggedInUID&#34;) is None:
            res.body = &#34;Failed - not logged in&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        user_id = session.data[&#34;loggedInUID&#34;]

        # password for source already exists
        password = None
        try:
            db_cursor.execute(f&#34;SELECT Password FROM Passwords WHERE Source=? AND UserID=?&#34;, source, user_id)
            password = db_cursor.fetchall()
        except pyodbc.Error as db_error:
            print(db_error)
            sql_state = db_error.args[0]
            sql_error_message = db_error.args[1]
            res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        if len(password) != 0:
            res.body = &#34;Failed - password for source already exists&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        # enter into database
        try:
            db_cursor.execute(f&#34;INSERT INTO Passwords (Source, Password, UserID) VALUES (?, CONVERT(BINARY(256),?,1), ?)&#34;, source, password_str, user_id)
            db_cursor.commit()
            res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)
        except pyodbc.Error as db_error:
            print(db_error)
            sql_state = db_error.args[0]
            sql_error_message = db_error.args[1]
            res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;

        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)

    # gets source and deletes password record with given source. Returns ascii for success or failure
    def delete_password(self, req, res, session):
        &#34;&#34;&#34;
        Deletes the password for a specific source for the logged in user.

        Args:
            req (CommunicationProtocol): The request message.
            res (CommunicationProtocol): The response message.
            session (Session): The current session.

        The request body should contain the source as an ASCII string.

        The response body will contain an ASCII string indicating success or failure.
        &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        source = req.body.decode(&#34;ascii&#34;)

        # no session
        if session is None:
            res.body = &#34;Failed - no session&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        # user is not logged in
        if session.data.get(&#34;loggedInUID&#34;) is None:
            res.body = &#34;Failed - not logged in&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        user_id = session.data[&#34;loggedInUID&#34;]

        # password for source doesn&#39;t exists
        password = None
        try:
            db_cursor.execute(f&#34;SELECT Password FROM Passwords WHERE Source=? AND UserID=?&#34;, source, user_id)
            password = db_cursor.fetchall()
        except pyodbc.Error as db_error:
            print(db_error)
            sql_state = db_error.args[0]
            sql_error_message = db_error.args[1]
            res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        if len(password) == 0:
            res.body = &#34;Failed - password for source doesn&#39;t exist&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        # delete password record from database
        try:
            db_cursor.execute(f&#34;DELETE FROM Passwords WHERE Source=? AND UserID=?&#34;, source, user_id)
            db_cursor.commit()
            res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)
        except pyodbc.Error as db_error:
            print(db_error)
            sql_state = db_error.args[0]
            sql_error_message = db_error.args[1]
            res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;

        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)

    # receives nothing, deletes all user records of logged in user. Returns ascii on success or failure
    def delete_user(self, req, res, session):
        &#34;&#34;&#34;
        Deletes the currently logged-in user.

        Args:
            req (CommunicationProtocol): The request message.
            res (CommunicationProtocol): The response message.
            session (Session): The current session.

        The response body will contain an ASCII string indicating success or failure.
        &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        # no session
        if session is None:
            res.body = &#34;Failed - no session&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;delete_user&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        # user is not logged in
        if session.data.get(&#34;loggedInUID&#34;) is None:
            res.body = &#34;Failed - not logged in&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;delete_user&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        user_id = session.data[&#34;loggedInUID&#34;]

        try:
            # delete all password records tied to user id
            db_cursor.execute(f&#34;DELETE FROM Passwords WHERE UserID=?&#34;, user_id)

            # delete user record tied to user id
            db_cursor.execute(f&#34;DELETE FROM Users WHERE ID=?&#34;, user_id)

            # commit execution
            db_cursor.commit()

            res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)
        except pyodbc.Error as db_error:
            db_cursor.rollback()

            print(db_error)
            sql_state = db_error.args[0]
            sql_error_message = db_error.args[1]
            res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;

        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;delete_user&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PasswordManager.PasswordManagerServer"><code class="flex name class">
<span>class <span class="ident">PasswordManagerServer</span></span>
<span>(</span><span>host, port, db_connection_string, with_ssl)</span>
</code></dt>
<dd>
<div class="desc"><p>A server for managing user passwords with various functionalities such as user creation, login,
retrieving and setting passwords, and deleting users.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>server</code></strong> :&ensp;<code>CommunicationProtocolServer</code></dt>
<dd>The communication protocol server instance.</dd>
<dt><strong><code>db_connection</code></strong> :&ensp;<code>pyodbc.Connection</code></dt>
<dd>The database connection.</dd>
</dl>
<h2 id="constructor">Constructor</h2>
<p>Initializes the PasswordManagerServer with the specified parameters.</p>
<p>Args:
host (str): The host address.
port (int): The port number.
db_connection_string (str): The database connection string.
with_ssl (bool): Whether to use SSL.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PasswordManagerServer:
    &#34;&#34;&#34;
    A server for managing user passwords with various functionalities such as user creation, login,
    retrieving and setting passwords, and deleting users.

    Attributes:
        server (CommunicationProtocolServer): The communication protocol server instance.
        db_connection (pyodbc.Connection): The database connection.
    &#34;&#34;&#34;

    def __init__(self, host, port, db_connection_string, with_ssl):
        &#34;&#34;&#34;
        Constructor:
            Initializes the PasswordManagerServer with the specified parameters.

            Args:
                host (str): The host address.
                port (int): The port number.
                db_connection_string (str): The database connection string.
                with_ssl (bool): Whether to use SSL.
        &#34;&#34;&#34;

        self.server = CommunicationProtocolServer(host, port, 10800, with_ssl)  # session ttl is 3 hours
        self.db_connection = pyodbc.connect(db_connection_string)

        self.server.handle_method(&#34;create_user&#34;, self.create_user)
        self.server.handle_method(&#34;login_request&#34;, self.login_request)
        self.server.handle_method(&#34;login_test&#34;, self.login_test)
        self.server.handle_method(&#34;get_sources&#34;, self.get_sources)
        self.server.handle_method(&#34;get_password&#34;, self.get_password)
        self.server.handle_method(&#34;set_password&#34;, self.set_password)
        self.server.handle_method(&#34;delete_password&#34;, self.delete_password)
        self.server.handle_method(&#34;delete_user&#34;, self.delete_user)

    def start_server(self):
        &#34;&#34;&#34;
        Starts the server to listen for incoming requests.
        &#34;&#34;&#34;

        self.server.serve_forever()

    # receive json with publicKey, userName and create such user
    # returns ascii with info on success or error
    def create_user(self, req, res, session):
        &#34;&#34;&#34;
        Creates a new user with the provided public key and username.

        Args:
            req (CommunicationProtocol): The request message.
            res (CommunicationProtocol): The response message.
            session (Session): The current session.

        The request body should contain a JSON object with the following keys:
            - publicKey (str): The user&#39;s public key, encoded in base64.
            - userName (str): The username.

        The response body will contain an ASCII string indicating success or error.
        &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        body_str = req.body.decode(&#34;ascii&#34;)
        body_json = json.loads(body_str)

        public_key_bytes = base64.b64decode(body_json[&#34;publicKey&#34;])
        user_name = body_json[&#34;userName&#34;]

        try:
            # check if there already exists a user with given username
            public_key_str = f&#34;0x{public_key_bytes.hex()}&#34;
            db_cursor.execute(f&#34;SELECT UserName, PublicKey FROM Users WHERE UserName=?&#34;, user_name)
            user_with_same_username = len(db_cursor.fetchall()) != 0
            db_cursor.execute(f&#34;SELECT UserName, PublicKey FROM Users WHERE PublicKey=?&#34;, public_key_str)
            user_with_same_public_key = len(db_cursor.fetchall()) != 0

            if user_with_same_username:
                res.body = &#34;User with this username already exists, choose a different username&#34;.encode(&#34;ascii&#34;)
            elif user_with_same_public_key:
                res.body = &#34;User with this public key already exists, choose a different public key&#34;.encode(&#34;ascii&#34;)
            else:
                db_cursor.execute(f&#34;INSERT INTO Users (UserName, PublicKey) VALUES (?, CONVERT(VARBINARY(300),?,1))&#34;, user_name, public_key_str)
                db_cursor.commit()
                res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)

            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;create_user&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
        except pyodbc.Error as db_error:
            print(db_error)
            sql_state = db_error.args[0]
            sql_error_message = db_error.args[1]
            res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;create_user&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)

    # receive username in ascii and return encrypted random 64 bits, no body is returned on error
    def login_request(self, req, res, session):
        &#34;&#34;&#34;
        Handles a login request by returning an encrypted random 64-bit number.

        Args:
            req (CommunicationProtocol): The request message.
            res (CommunicationProtocol): The response message.
            session (Session): The current session.

        The request body should contain the username as an ASCII string.

        The response body will contain the encrypted random 64-bit number, or no body if there is an error.
        &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        user_name = req.body.decode(&#34;ascii&#34;)

        # get user&#39;s public key from database
        public_key_bytes = None
        try:
            db_cursor.execute(f&#34;SELECT PublicKey FROM Users WHERE UserName=?&#34;, user_name)
            public_key_bytes = db_cursor.fetchall()
        except pyodbc.Error as db_error:
            print(db_error)
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;login_request&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;bytes&#34;)
            return

        # user does not exists or this was called without a session
        if len(public_key_bytes) == 0 or session is None:
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
        else:
            public_key_bytes = public_key_bytes[0][0]
            rsa_key = RSA.importKey(public_key_bytes)
            cipher = PKCS1_v1_5.new(rsa_key)

            # generate random 64 bit number and encrypt it
            random_number = randbytes(8)
            random_number_encrypted = cipher.encrypt(random_number)

            # return number in body
            res.body = random_number_encrypted
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))

            # store number in session and user name
            session.data[&#34;loginNumber&#34;] = random_number
            session.data[&#34;loginUserName&#34;] = user_name

        res.set_header_value(&#34;Method&#34;, &#34;login_request&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;bytes&#34;)

    # receive decrypted 64 bits and if they match bits in session store logged in uid
    # returns ascii with info for success or failure
    def login_test(self, req, res, session):
        &#34;&#34;&#34;
        Tests the login by verifying the decrypted 64-bit number.

        Args:
            req (CommunicationProtocol): The request message.
            res (CommunicationProtocol): The response message.
            session (Session): The current session.

        The request body should contain the decrypted 64-bit number as bytes.

        The response body will contain an ASCII string indicating success or failure.
        &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        decrypted_number_bytes = req.body

        if session is None:
            res.body = &#34;Failed - no session&#34;.encode(&#34;ascii&#34;)
        elif session.data.get(&#34;loginNumber&#34;) is None:
            res.body = &#34;Failed - no login number in session&#34;.encode(&#34;ascii&#34;)
        elif session.data.get(&#34;loginUserName&#34;) is None:
            res.body = &#34;Failed - no login username in session&#34;.encode(&#34;ascii&#34;)
        elif decrypted_number_bytes != session.data[&#34;loginNumber&#34;]:
            res.body = &#34;Failed - incorrect number&#34;.encode(&#34;ascii&#34;)
        else:  # correct number and data is in session
            try:
                # get user id from database
                user_name = session.data[&#34;loginUserName&#34;]
                db_cursor.execute(f&#34;SELECT ID FROM Users WHERE UserName=?&#34;, user_name)
                user_id = db_cursor.fetchall()

                if len(user_id) == 0:
                    res.body = f&#34;Failed - user {user_name} doesn&#39;t exist&#34;.encode(&#34;ascii&#34;)
                else:
                    session.data[&#34;loggedInUID&#34;] = user_id[0][0]
                    res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)
            except pyodbc.Error as db_error:
                print(db_error)
                sql_state = db_error.args[0]
                sql_error_message = db_error.args[1]
                res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;

        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;login_test&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)

    # returns json array of all sources tied to user in session. Return no body if error
    def get_sources(self, req, res, session):
        &#34;&#34;&#34;
        Retrieves the sources tied to the logged-in user.

        Args:
            req (CommunicationProtocol): The request message.
            res (CommunicationProtocol): The response message.
            session (Session): The current session.

        The response body will contain a JSON array of sources, or no body if there is an error.
        &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        # no session
        if session is None:
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;get_sources&#34;)

        # user is not logged in
        if session.data.get(&#34;loggedInUID&#34;) is None:
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;get_sources&#34;)
            return

        user_id = session.data[&#34;loggedInUID&#34;]

        # get sources
        sources_db = None
        sources = []
        try:
            db_cursor.execute(f&#34;SELECT Source FROM Passwords WHERE UserID=?&#34;, user_id)
            sources_db = db_cursor.fetchall()
        except pyodbc.Error as db_error:
            print(db_error)
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;get_sources&#34;)
            return

        for source_item in sources_db:
            sources.append(source_item[0])

        sources_json = json.dumps(sources)
        sources_json = sources_json.encode(&#34;ascii&#34;)

        res.body = sources_json
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;get_sources&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii json&#34;)

    # gets ascii string of password source and returns encrypted password, no body if error
    def get_password(self, req, res, session):
        &#34;&#34;&#34;
         Retrieves the password for the specified source for the logged in user.

         Args:
             req (CommunicationProtocol): The request message.
             res (CommunicationProtocol): The response message.
             session (Session): The current session.

         The request body should contain the source as an ASCII string.

         The response body will contain the encrypted password, or no body if there is an error.
         &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        source = req.body.decode(&#34;ascii&#34;)

        # no session
        if session is None:
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
            return

        # user is not logged in
        if session.data.get(&#34;loggedInUID&#34;) is None:
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
            return

        user_id = session.data[&#34;loggedInUID&#34;]

        password = None
        try:
            db_cursor.execute(f&#34;SELECT Password FROM Passwords WHERE UserID=? AND Source=?&#34;, user_id, source)
            password = db_cursor.fetchall()
        except pyodbc.Error as db_error:
            print(db_error)
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
            return

        # no password found
        if len(password) == 0:
            res.body = None
            res.set_header_value(&#34;Content-Length&#34;, 0)
            res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
            return

        password = password[0][0]

        res.body = password
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;bytes&#34;)

    # gets json of source and password encoded in base64, returns ascii if success or failure
    def set_password(self, req, res, session):
        &#34;&#34;&#34;
        Sets the password for a specific source for the logged in user.

        Args:
            req (CommunicationProtocol): The request message.
            res (CommunicationProtocol): The response message.
            session (Session): The current session.

        The request body should contain a JSON object with the following keys:
            - source (str): The source.
            - password (str): The password.

        The response body will contain an ASCII string indicating success or failure.
        &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        body_str = req.body.decode(&#34;ascii&#34;)
        body_json = json.loads(body_str)

        source = body_json[&#34;source&#34;]
        password = base64.b64decode(body_json[&#34;password&#34;])
        password_str = f&#34;0x{password.hex()}&#34;

        # no session
        if session is None:
            res.body = &#34;Failed - no session&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        # user is not logged in
        if session.data.get(&#34;loggedInUID&#34;) is None:
            res.body = &#34;Failed - not logged in&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        user_id = session.data[&#34;loggedInUID&#34;]

        # password for source already exists
        password = None
        try:
            db_cursor.execute(f&#34;SELECT Password FROM Passwords WHERE Source=? AND UserID=?&#34;, source, user_id)
            password = db_cursor.fetchall()
        except pyodbc.Error as db_error:
            print(db_error)
            sql_state = db_error.args[0]
            sql_error_message = db_error.args[1]
            res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        if len(password) != 0:
            res.body = &#34;Failed - password for source already exists&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        # enter into database
        try:
            db_cursor.execute(f&#34;INSERT INTO Passwords (Source, Password, UserID) VALUES (?, CONVERT(BINARY(256),?,1), ?)&#34;, source, password_str, user_id)
            db_cursor.commit()
            res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)
        except pyodbc.Error as db_error:
            print(db_error)
            sql_state = db_error.args[0]
            sql_error_message = db_error.args[1]
            res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;

        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)

    # gets source and deletes password record with given source. Returns ascii for success or failure
    def delete_password(self, req, res, session):
        &#34;&#34;&#34;
        Deletes the password for a specific source for the logged in user.

        Args:
            req (CommunicationProtocol): The request message.
            res (CommunicationProtocol): The response message.
            session (Session): The current session.

        The request body should contain the source as an ASCII string.

        The response body will contain an ASCII string indicating success or failure.
        &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        source = req.body.decode(&#34;ascii&#34;)

        # no session
        if session is None:
            res.body = &#34;Failed - no session&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        # user is not logged in
        if session.data.get(&#34;loggedInUID&#34;) is None:
            res.body = &#34;Failed - not logged in&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        user_id = session.data[&#34;loggedInUID&#34;]

        # password for source doesn&#39;t exists
        password = None
        try:
            db_cursor.execute(f&#34;SELECT Password FROM Passwords WHERE Source=? AND UserID=?&#34;, source, user_id)
            password = db_cursor.fetchall()
        except pyodbc.Error as db_error:
            print(db_error)
            sql_state = db_error.args[0]
            sql_error_message = db_error.args[1]
            res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        if len(password) == 0:
            res.body = &#34;Failed - password for source doesn&#39;t exist&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        # delete password record from database
        try:
            db_cursor.execute(f&#34;DELETE FROM Passwords WHERE Source=? AND UserID=?&#34;, source, user_id)
            db_cursor.commit()
            res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)
        except pyodbc.Error as db_error:
            print(db_error)
            sql_state = db_error.args[0]
            sql_error_message = db_error.args[1]
            res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;

        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)

    # receives nothing, deletes all user records of logged in user. Returns ascii on success or failure
    def delete_user(self, req, res, session):
        &#34;&#34;&#34;
        Deletes the currently logged-in user.

        Args:
            req (CommunicationProtocol): The request message.
            res (CommunicationProtocol): The response message.
            session (Session): The current session.

        The response body will contain an ASCII string indicating success or failure.
        &#34;&#34;&#34;

        db_cursor = self.db_connection.cursor()

        # no session
        if session is None:
            res.body = &#34;Failed - no session&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;delete_user&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        # user is not logged in
        if session.data.get(&#34;loggedInUID&#34;) is None:
            res.body = &#34;Failed - not logged in&#34;.encode(&#34;ascii&#34;)
            res.set_header_value(&#34;Content-Length&#34;, len(res.body))
            res.set_header_value(&#34;Method&#34;, &#34;delete_user&#34;)
            res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
            return

        user_id = session.data[&#34;loggedInUID&#34;]

        try:
            # delete all password records tied to user id
            db_cursor.execute(f&#34;DELETE FROM Passwords WHERE UserID=?&#34;, user_id)

            # delete user record tied to user id
            db_cursor.execute(f&#34;DELETE FROM Users WHERE ID=?&#34;, user_id)

            # commit execution
            db_cursor.commit()

            res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)
        except pyodbc.Error as db_error:
            db_cursor.rollback()

            print(db_error)
            sql_state = db_error.args[0]
            sql_error_message = db_error.args[1]
            res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;

        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;delete_user&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PasswordManager.PasswordManagerServer.create_user"><code class="name flex">
<span>def <span class="ident">create_user</span></span>(<span>self, req, res, session)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new user with the provided public key and username.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>req</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The request message.</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The response message.</dd>
<dt><strong><code>session</code></strong> :&ensp;<code>Session</code></dt>
<dd>The current session.</dd>
</dl>
<p>The request body should contain a JSON object with the following keys:
- publicKey (str): The user's public key, encoded in base64.
- userName (str): The username.</p>
<p>The response body will contain an ASCII string indicating success or error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_user(self, req, res, session):
    &#34;&#34;&#34;
    Creates a new user with the provided public key and username.

    Args:
        req (CommunicationProtocol): The request message.
        res (CommunicationProtocol): The response message.
        session (Session): The current session.

    The request body should contain a JSON object with the following keys:
        - publicKey (str): The user&#39;s public key, encoded in base64.
        - userName (str): The username.

    The response body will contain an ASCII string indicating success or error.
    &#34;&#34;&#34;

    db_cursor = self.db_connection.cursor()

    body_str = req.body.decode(&#34;ascii&#34;)
    body_json = json.loads(body_str)

    public_key_bytes = base64.b64decode(body_json[&#34;publicKey&#34;])
    user_name = body_json[&#34;userName&#34;]

    try:
        # check if there already exists a user with given username
        public_key_str = f&#34;0x{public_key_bytes.hex()}&#34;
        db_cursor.execute(f&#34;SELECT UserName, PublicKey FROM Users WHERE UserName=?&#34;, user_name)
        user_with_same_username = len(db_cursor.fetchall()) != 0
        db_cursor.execute(f&#34;SELECT UserName, PublicKey FROM Users WHERE PublicKey=?&#34;, public_key_str)
        user_with_same_public_key = len(db_cursor.fetchall()) != 0

        if user_with_same_username:
            res.body = &#34;User with this username already exists, choose a different username&#34;.encode(&#34;ascii&#34;)
        elif user_with_same_public_key:
            res.body = &#34;User with this public key already exists, choose a different public key&#34;.encode(&#34;ascii&#34;)
        else:
            db_cursor.execute(f&#34;INSERT INTO Users (UserName, PublicKey) VALUES (?, CONVERT(VARBINARY(300),?,1))&#34;, user_name, public_key_str)
            db_cursor.commit()
            res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)

        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;create_user&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
    except pyodbc.Error as db_error:
        print(db_error)
        sql_state = db_error.args[0]
        sql_error_message = db_error.args[1]
        res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;create_user&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)</code></pre>
</details>
</dd>
<dt id="PasswordManager.PasswordManagerServer.delete_password"><code class="name flex">
<span>def <span class="ident">delete_password</span></span>(<span>self, req, res, session)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the password for a specific source for the logged in user.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>req</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The request message.</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The response message.</dd>
<dt><strong><code>session</code></strong> :&ensp;<code>Session</code></dt>
<dd>The current session.</dd>
</dl>
<p>The request body should contain the source as an ASCII string.</p>
<p>The response body will contain an ASCII string indicating success or failure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_password(self, req, res, session):
    &#34;&#34;&#34;
    Deletes the password for a specific source for the logged in user.

    Args:
        req (CommunicationProtocol): The request message.
        res (CommunicationProtocol): The response message.
        session (Session): The current session.

    The request body should contain the source as an ASCII string.

    The response body will contain an ASCII string indicating success or failure.
    &#34;&#34;&#34;

    db_cursor = self.db_connection.cursor()

    source = req.body.decode(&#34;ascii&#34;)

    # no session
    if session is None:
        res.body = &#34;Failed - no session&#34;.encode(&#34;ascii&#34;)
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
        return

    # user is not logged in
    if session.data.get(&#34;loggedInUID&#34;) is None:
        res.body = &#34;Failed - not logged in&#34;.encode(&#34;ascii&#34;)
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
        return

    user_id = session.data[&#34;loggedInUID&#34;]

    # password for source doesn&#39;t exists
    password = None
    try:
        db_cursor.execute(f&#34;SELECT Password FROM Passwords WHERE Source=? AND UserID=?&#34;, source, user_id)
        password = db_cursor.fetchall()
    except pyodbc.Error as db_error:
        print(db_error)
        sql_state = db_error.args[0]
        sql_error_message = db_error.args[1]
        res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
        return

    if len(password) == 0:
        res.body = &#34;Failed - password for source doesn&#39;t exist&#34;.encode(&#34;ascii&#34;)
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
        return

    # delete password record from database
    try:
        db_cursor.execute(f&#34;DELETE FROM Passwords WHERE Source=? AND UserID=?&#34;, source, user_id)
        db_cursor.commit()
        res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)
    except pyodbc.Error as db_error:
        print(db_error)
        sql_state = db_error.args[0]
        sql_error_message = db_error.args[1]
        res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;

    res.set_header_value(&#34;Content-Length&#34;, len(res.body))
    res.set_header_value(&#34;Method&#34;, &#34;delete_password&#34;)
    res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)</code></pre>
</details>
</dd>
<dt id="PasswordManager.PasswordManagerServer.delete_user"><code class="name flex">
<span>def <span class="ident">delete_user</span></span>(<span>self, req, res, session)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the currently logged-in user.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>req</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The request message.</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The response message.</dd>
<dt><strong><code>session</code></strong> :&ensp;<code>Session</code></dt>
<dd>The current session.</dd>
</dl>
<p>The response body will contain an ASCII string indicating success or failure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_user(self, req, res, session):
    &#34;&#34;&#34;
    Deletes the currently logged-in user.

    Args:
        req (CommunicationProtocol): The request message.
        res (CommunicationProtocol): The response message.
        session (Session): The current session.

    The response body will contain an ASCII string indicating success or failure.
    &#34;&#34;&#34;

    db_cursor = self.db_connection.cursor()

    # no session
    if session is None:
        res.body = &#34;Failed - no session&#34;.encode(&#34;ascii&#34;)
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;delete_user&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
        return

    # user is not logged in
    if session.data.get(&#34;loggedInUID&#34;) is None:
        res.body = &#34;Failed - not logged in&#34;.encode(&#34;ascii&#34;)
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;delete_user&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
        return

    user_id = session.data[&#34;loggedInUID&#34;]

    try:
        # delete all password records tied to user id
        db_cursor.execute(f&#34;DELETE FROM Passwords WHERE UserID=?&#34;, user_id)

        # delete user record tied to user id
        db_cursor.execute(f&#34;DELETE FROM Users WHERE ID=?&#34;, user_id)

        # commit execution
        db_cursor.commit()

        res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)
    except pyodbc.Error as db_error:
        db_cursor.rollback()

        print(db_error)
        sql_state = db_error.args[0]
        sql_error_message = db_error.args[1]
        res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;

    res.set_header_value(&#34;Content-Length&#34;, len(res.body))
    res.set_header_value(&#34;Method&#34;, &#34;delete_user&#34;)
    res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)</code></pre>
</details>
</dd>
<dt id="PasswordManager.PasswordManagerServer.get_password"><code class="name flex">
<span>def <span class="ident">get_password</span></span>(<span>self, req, res, session)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the password for the specified source for the logged in user.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>req</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The request message.</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The response message.</dd>
<dt><strong><code>session</code></strong> :&ensp;<code>Session</code></dt>
<dd>The current session.</dd>
</dl>
<p>The request body should contain the source as an ASCII string.</p>
<p>The response body will contain the encrypted password, or no body if there is an error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_password(self, req, res, session):
    &#34;&#34;&#34;
     Retrieves the password for the specified source for the logged in user.

     Args:
         req (CommunicationProtocol): The request message.
         res (CommunicationProtocol): The response message.
         session (Session): The current session.

     The request body should contain the source as an ASCII string.

     The response body will contain the encrypted password, or no body if there is an error.
     &#34;&#34;&#34;

    db_cursor = self.db_connection.cursor()

    source = req.body.decode(&#34;ascii&#34;)

    # no session
    if session is None:
        res.body = None
        res.set_header_value(&#34;Content-Length&#34;, 0)
        res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
        return

    # user is not logged in
    if session.data.get(&#34;loggedInUID&#34;) is None:
        res.body = None
        res.set_header_value(&#34;Content-Length&#34;, 0)
        res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
        return

    user_id = session.data[&#34;loggedInUID&#34;]

    password = None
    try:
        db_cursor.execute(f&#34;SELECT Password FROM Passwords WHERE UserID=? AND Source=?&#34;, user_id, source)
        password = db_cursor.fetchall()
    except pyodbc.Error as db_error:
        print(db_error)
        res.body = None
        res.set_header_value(&#34;Content-Length&#34;, 0)
        res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
        return

    # no password found
    if len(password) == 0:
        res.body = None
        res.set_header_value(&#34;Content-Length&#34;, 0)
        res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
        return

    password = password[0][0]

    res.body = password
    res.set_header_value(&#34;Content-Length&#34;, len(res.body))
    res.set_header_value(&#34;Method&#34;, &#34;get_password&#34;)
    res.set_header_value(&#34;Content-Type&#34;, &#34;bytes&#34;)</code></pre>
</details>
</dd>
<dt id="PasswordManager.PasswordManagerServer.get_sources"><code class="name flex">
<span>def <span class="ident">get_sources</span></span>(<span>self, req, res, session)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the sources tied to the logged-in user.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>req</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The request message.</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The response message.</dd>
<dt><strong><code>session</code></strong> :&ensp;<code>Session</code></dt>
<dd>The current session.</dd>
</dl>
<p>The response body will contain a JSON array of sources, or no body if there is an error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sources(self, req, res, session):
    &#34;&#34;&#34;
    Retrieves the sources tied to the logged-in user.

    Args:
        req (CommunicationProtocol): The request message.
        res (CommunicationProtocol): The response message.
        session (Session): The current session.

    The response body will contain a JSON array of sources, or no body if there is an error.
    &#34;&#34;&#34;

    db_cursor = self.db_connection.cursor()

    # no session
    if session is None:
        res.body = None
        res.set_header_value(&#34;Content-Length&#34;, 0)
        res.set_header_value(&#34;Method&#34;, &#34;get_sources&#34;)

    # user is not logged in
    if session.data.get(&#34;loggedInUID&#34;) is None:
        res.body = None
        res.set_header_value(&#34;Content-Length&#34;, 0)
        res.set_header_value(&#34;Method&#34;, &#34;get_sources&#34;)
        return

    user_id = session.data[&#34;loggedInUID&#34;]

    # get sources
    sources_db = None
    sources = []
    try:
        db_cursor.execute(f&#34;SELECT Source FROM Passwords WHERE UserID=?&#34;, user_id)
        sources_db = db_cursor.fetchall()
    except pyodbc.Error as db_error:
        print(db_error)
        res.body = None
        res.set_header_value(&#34;Content-Length&#34;, 0)
        res.set_header_value(&#34;Method&#34;, &#34;get_sources&#34;)
        return

    for source_item in sources_db:
        sources.append(source_item[0])

    sources_json = json.dumps(sources)
    sources_json = sources_json.encode(&#34;ascii&#34;)

    res.body = sources_json
    res.set_header_value(&#34;Content-Length&#34;, len(res.body))
    res.set_header_value(&#34;Method&#34;, &#34;get_sources&#34;)
    res.set_header_value(&#34;Content-Type&#34;, &#34;ascii json&#34;)</code></pre>
</details>
</dd>
<dt id="PasswordManager.PasswordManagerServer.login_request"><code class="name flex">
<span>def <span class="ident">login_request</span></span>(<span>self, req, res, session)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles a login request by returning an encrypted random 64-bit number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>req</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The request message.</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The response message.</dd>
<dt><strong><code>session</code></strong> :&ensp;<code>Session</code></dt>
<dd>The current session.</dd>
</dl>
<p>The request body should contain the username as an ASCII string.</p>
<p>The response body will contain the encrypted random 64-bit number, or no body if there is an error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def login_request(self, req, res, session):
    &#34;&#34;&#34;
    Handles a login request by returning an encrypted random 64-bit number.

    Args:
        req (CommunicationProtocol): The request message.
        res (CommunicationProtocol): The response message.
        session (Session): The current session.

    The request body should contain the username as an ASCII string.

    The response body will contain the encrypted random 64-bit number, or no body if there is an error.
    &#34;&#34;&#34;

    db_cursor = self.db_connection.cursor()

    user_name = req.body.decode(&#34;ascii&#34;)

    # get user&#39;s public key from database
    public_key_bytes = None
    try:
        db_cursor.execute(f&#34;SELECT PublicKey FROM Users WHERE UserName=?&#34;, user_name)
        public_key_bytes = db_cursor.fetchall()
    except pyodbc.Error as db_error:
        print(db_error)
        res.body = None
        res.set_header_value(&#34;Content-Length&#34;, 0)
        res.set_header_value(&#34;Method&#34;, &#34;login_request&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;bytes&#34;)
        return

    # user does not exists or this was called without a session
    if len(public_key_bytes) == 0 or session is None:
        res.body = None
        res.set_header_value(&#34;Content-Length&#34;, 0)
    else:
        public_key_bytes = public_key_bytes[0][0]
        rsa_key = RSA.importKey(public_key_bytes)
        cipher = PKCS1_v1_5.new(rsa_key)

        # generate random 64 bit number and encrypt it
        random_number = randbytes(8)
        random_number_encrypted = cipher.encrypt(random_number)

        # return number in body
        res.body = random_number_encrypted
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))

        # store number in session and user name
        session.data[&#34;loginNumber&#34;] = random_number
        session.data[&#34;loginUserName&#34;] = user_name

    res.set_header_value(&#34;Method&#34;, &#34;login_request&#34;)
    res.set_header_value(&#34;Content-Type&#34;, &#34;bytes&#34;)</code></pre>
</details>
</dd>
<dt id="PasswordManager.PasswordManagerServer.login_test"><code class="name flex">
<span>def <span class="ident">login_test</span></span>(<span>self, req, res, session)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests the login by verifying the decrypted 64-bit number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>req</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The request message.</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The response message.</dd>
<dt><strong><code>session</code></strong> :&ensp;<code>Session</code></dt>
<dd>The current session.</dd>
</dl>
<p>The request body should contain the decrypted 64-bit number as bytes.</p>
<p>The response body will contain an ASCII string indicating success or failure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def login_test(self, req, res, session):
    &#34;&#34;&#34;
    Tests the login by verifying the decrypted 64-bit number.

    Args:
        req (CommunicationProtocol): The request message.
        res (CommunicationProtocol): The response message.
        session (Session): The current session.

    The request body should contain the decrypted 64-bit number as bytes.

    The response body will contain an ASCII string indicating success or failure.
    &#34;&#34;&#34;

    db_cursor = self.db_connection.cursor()

    decrypted_number_bytes = req.body

    if session is None:
        res.body = &#34;Failed - no session&#34;.encode(&#34;ascii&#34;)
    elif session.data.get(&#34;loginNumber&#34;) is None:
        res.body = &#34;Failed - no login number in session&#34;.encode(&#34;ascii&#34;)
    elif session.data.get(&#34;loginUserName&#34;) is None:
        res.body = &#34;Failed - no login username in session&#34;.encode(&#34;ascii&#34;)
    elif decrypted_number_bytes != session.data[&#34;loginNumber&#34;]:
        res.body = &#34;Failed - incorrect number&#34;.encode(&#34;ascii&#34;)
    else:  # correct number and data is in session
        try:
            # get user id from database
            user_name = session.data[&#34;loginUserName&#34;]
            db_cursor.execute(f&#34;SELECT ID FROM Users WHERE UserName=?&#34;, user_name)
            user_id = db_cursor.fetchall()

            if len(user_id) == 0:
                res.body = f&#34;Failed - user {user_name} doesn&#39;t exist&#34;.encode(&#34;ascii&#34;)
            else:
                session.data[&#34;loggedInUID&#34;] = user_id[0][0]
                res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)
        except pyodbc.Error as db_error:
            print(db_error)
            sql_state = db_error.args[0]
            sql_error_message = db_error.args[1]
            res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;

    res.set_header_value(&#34;Content-Length&#34;, len(res.body))
    res.set_header_value(&#34;Method&#34;, &#34;login_test&#34;)
    res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)</code></pre>
</details>
</dd>
<dt id="PasswordManager.PasswordManagerServer.set_password"><code class="name flex">
<span>def <span class="ident">set_password</span></span>(<span>self, req, res, session)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the password for a specific source for the logged in user.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>req</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The request message.</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The response message.</dd>
<dt><strong><code>session</code></strong> :&ensp;<code>Session</code></dt>
<dd>The current session.</dd>
</dl>
<p>The request body should contain a JSON object with the following keys:
- source (str): The source.
- password (str): The password.</p>
<p>The response body will contain an ASCII string indicating success or failure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_password(self, req, res, session):
    &#34;&#34;&#34;
    Sets the password for a specific source for the logged in user.

    Args:
        req (CommunicationProtocol): The request message.
        res (CommunicationProtocol): The response message.
        session (Session): The current session.

    The request body should contain a JSON object with the following keys:
        - source (str): The source.
        - password (str): The password.

    The response body will contain an ASCII string indicating success or failure.
    &#34;&#34;&#34;

    db_cursor = self.db_connection.cursor()

    body_str = req.body.decode(&#34;ascii&#34;)
    body_json = json.loads(body_str)

    source = body_json[&#34;source&#34;]
    password = base64.b64decode(body_json[&#34;password&#34;])
    password_str = f&#34;0x{password.hex()}&#34;

    # no session
    if session is None:
        res.body = &#34;Failed - no session&#34;.encode(&#34;ascii&#34;)
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
        return

    # user is not logged in
    if session.data.get(&#34;loggedInUID&#34;) is None:
        res.body = &#34;Failed - not logged in&#34;.encode(&#34;ascii&#34;)
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
        return

    user_id = session.data[&#34;loggedInUID&#34;]

    # password for source already exists
    password = None
    try:
        db_cursor.execute(f&#34;SELECT Password FROM Passwords WHERE Source=? AND UserID=?&#34;, source, user_id)
        password = db_cursor.fetchall()
    except pyodbc.Error as db_error:
        print(db_error)
        sql_state = db_error.args[0]
        sql_error_message = db_error.args[1]
        res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
        return

    if len(password) != 0:
        res.body = &#34;Failed - password for source already exists&#34;.encode(&#34;ascii&#34;)
        res.set_header_value(&#34;Content-Length&#34;, len(res.body))
        res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
        res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)
        return

    # enter into database
    try:
        db_cursor.execute(f&#34;INSERT INTO Passwords (Source, Password, UserID) VALUES (?, CONVERT(BINARY(256),?,1), ?)&#34;, source, password_str, user_id)
        db_cursor.commit()
        res.body = &#34;Success&#34;.encode(&#34;ascii&#34;)
    except pyodbc.Error as db_error:
        print(db_error)
        sql_state = db_error.args[0]
        sql_error_message = db_error.args[1]
        res.body = f&#34;Failed - server database error\nSQL STATE: {sql_state}\nError message: {sql_error_message}&#34;

    res.set_header_value(&#34;Content-Length&#34;, len(res.body))
    res.set_header_value(&#34;Method&#34;, &#34;set_password&#34;)
    res.set_header_value(&#34;Content-Type&#34;, &#34;ascii&#34;)</code></pre>
</details>
</dd>
<dt id="PasswordManager.PasswordManagerServer.start_server"><code class="name flex">
<span>def <span class="ident">start_server</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the server to listen for incoming requests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_server(self):
    &#34;&#34;&#34;
    Starts the server to listen for incoming requests.
    &#34;&#34;&#34;

    self.server.serve_forever()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PasswordManager.PasswordManagerServer" href="#PasswordManager.PasswordManagerServer">PasswordManagerServer</a></code></h4>
<ul class="two-column">
<li><code><a title="PasswordManager.PasswordManagerServer.create_user" href="#PasswordManager.PasswordManagerServer.create_user">create_user</a></code></li>
<li><code><a title="PasswordManager.PasswordManagerServer.delete_password" href="#PasswordManager.PasswordManagerServer.delete_password">delete_password</a></code></li>
<li><code><a title="PasswordManager.PasswordManagerServer.delete_user" href="#PasswordManager.PasswordManagerServer.delete_user">delete_user</a></code></li>
<li><code><a title="PasswordManager.PasswordManagerServer.get_password" href="#PasswordManager.PasswordManagerServer.get_password">get_password</a></code></li>
<li><code><a title="PasswordManager.PasswordManagerServer.get_sources" href="#PasswordManager.PasswordManagerServer.get_sources">get_sources</a></code></li>
<li><code><a title="PasswordManager.PasswordManagerServer.login_request" href="#PasswordManager.PasswordManagerServer.login_request">login_request</a></code></li>
<li><code><a title="PasswordManager.PasswordManagerServer.login_test" href="#PasswordManager.PasswordManagerServer.login_test">login_test</a></code></li>
<li><code><a title="PasswordManager.PasswordManagerServer.set_password" href="#PasswordManager.PasswordManagerServer.set_password">set_password</a></code></li>
<li><code><a title="PasswordManager.PasswordManagerServer.start_server" href="#PasswordManager.PasswordManagerServer.start_server">start_server</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>