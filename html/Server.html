<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Server API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Server</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import socket
import ssl
import re
import string
import time
from random import randint
from threading import Thread
from threading import Lock
from CommunicationProtocol import CommunicationProtocol, CommunicationProtocolException
from Session import Session


# TCP Socket Server which binds to host and port given
# Each client connection is handled in different thread
# Client connections go through different handler functions
# handler functions are called in added order. Result of one handler goes to the next.
class Server:
    &#34;&#34;&#34;
    TCP Socket Server which binds to a given host and port.
    Each client connection is handled in a different thread.
    Client connections go through different handler functions.
    Handler functions are called in added order. The result of one handler goes to the next.

    Attributes:
        host (str): The host to bind the server to.
        port (int): The port to bind the server to.
        ssl_context (ssl.SSLContext): The SSL context for secure connections.
        server_socket (socket.socket): The server socket.
        handlers (list): List of handler functions to process client connections.
    &#34;&#34;&#34;

    def __init__(self, host, port, with_ssl):
        &#34;&#34;&#34;
        Constructor:
            Initializes the Server instance.

            Args:
                host (str): The host to bind the server to.
                port (int): The port to bind the server to.
                with_ssl (bool): Whether to use SSL for secure connections.
        &#34;&#34;&#34;

        self.port = port
        self.host = host

        self.ssl_context = None
        if with_ssl:
            self.ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
            self.ssl_context.load_cert_chain(certfile=r&#34;SSL/cert.pem&#34;, keyfile=r&#34;SSL/key.pem&#34;)

        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        self.handlers = []  # each handler is a function which takes client_socket, client_address, prev_result

    # add handler function to deal with client connection
    def add_handler(self, handler):
        &#34;&#34;&#34;
        Adds a handler function to process client connections.

        Args:
            handler (function): The handler function to add.
        &#34;&#34;&#34;

        self.handlers.append(handler)

    # remove handler function
    def remove_handler(self, handler):
        &#34;&#34;&#34;
        Removes a handler function.

        Args:
            handler (function): The handler function to remove.
        &#34;&#34;&#34;

        self.handlers.remove(handler)

    # receive message from client. Default receives 1024 bytes from client socket.
    def receive_message(self, client_socket, client_address):
        &#34;&#34;&#34;
        Receives a message from the client. Default receives 1024 bytes from client socket.

        Args:
            client_socket (socket.socket): The client socket.
            client_address (tuple): The client address.

        Returns:
            bytes: The received message.
        &#34;&#34;&#34;

        return client_socket.recv(1024)

    # what to do on client closing. Default just closes socket.
    def close_client(self, client_socket, client_address):
        &#34;&#34;&#34;
        Handles client closing. Default just closes the socket.

        Args:
            client_socket (socket.socket): The client socket.
            client_address (tuple): The client address.
        &#34;&#34;&#34;

        client_socket.close()

    # handle connection from client. message goes through all handler functions
    def handle_client(self, client_socket, client_address):
        &#34;&#34;&#34;
        Handles connection from the client.
        The message is received using receive_message function.
        The message then goes through all handler functions.
        At the end close_client function is called.

        Args:
            client_socket (socket.socket): The client socket.
            client_address (tuple): The client address.
        &#34;&#34;&#34;

        message = self.receive_message(client_socket, client_address)

        prev_result = message
        for handler in self.handlers:
            prev_result = handler(client_socket, client_address, prev_result)

        self.close_client(client_socket, client_address)

    # turn server on to forever serve
    def serve_forever(self):
        &#34;&#34;&#34;
        Turns the server on to serve forever.
        &#34;&#34;&#34;

        print(f&#34;Starting Server on host={self.host}, port={self.port}&#34;)
        self.server_socket.bind((self.host, self.port))

        server_socket = self.server_socket
        if self.ssl_context is not None:
            server_socket = self.ssl_context.wrap_socket(server_socket, server_side=True)

        while True:
            server_socket.listen()
            client_socket, client_address = server_socket.accept()
            print(f&#34;Received Connection from {client_address}&#34;)
            client_thread = Thread(target=self.handle_client, args=(client_socket, client_address))
            client_thread.start()


# Server with Storing Session capabilities
# todo is session cleanup thread safe?!
class SessionServer(Server):
    &#34;&#34;&#34;
    Server with storing session capabilities.

    Attributes:
        sessions (dict): Dictionary storing sessions with session tokens as keys and session objects as values.
        session_token_length (int): Length of the session token.
        session_ttl (int): Time-to-live for a session in seconds.
        session_cleanup_thread (threading.Thread): Thread to remove expired sessions.
    &#34;&#34;&#34;

    def __init__(self, host, port, session_token_length, session_ttl, with_ssl):
        &#34;&#34;&#34;
        Constructor:
             Initializes the SessionServer instance.

             Args:
                 host (str): The host to bind the server to.
                 port (int): The port to bind the server to.
                 session_token_length (int): Length of the session token.
                 session_ttl (int): Time-to-live for a session in seconds.
                 with_ssl (bool): Whether to use SSL for secure connections.
        &#34;&#34;&#34;

        super().__init__(host, port, with_ssl)

        self.sessions = dict()  # key is session token, value is session object
        self.session_token_length = session_token_length

        self.session_ttl = session_ttl  # number of seconds that session is allowed to live
        self.session_cleanup_thread = Thread(target=self.remove_sessions)

    def serve_forever(self):
        &#34;&#34;&#34;
        Turns the server on to serve forever and starts the session cleanup thread.
        &#34;&#34;&#34;

        self.session_cleanup_thread.start()
        super().serve_forever()

    # generate unique token for new session
    def generate_session_token(self, length):
        &#34;&#34;&#34;
        Generates a unique token for a new session.

        Args:
            length (int): Length of the session token.

        Returns:
            str: The generated session token.
        &#34;&#34;&#34;

        characters = string.ascii_lowercase + string.ascii_uppercase + string.digits
        token = &#34;&#34;

        while token in self.sessions or token == &#34;&#34;:
            token = &#34;&#34;
            for i in range(length):
                token += characters[randint(0, len(characters)-1)]

        return token

    # create a session and return its token
    def create_session(self):
        &#34;&#34;&#34;
         Creates a session and returns its token.

         Returns:
             str: The session token.
         &#34;&#34;&#34;

        token = self.generate_session_token(self.session_token_length)
        self.sessions[token] = Session()

        return token

    # get session associated with token
    def get_session(self, token):
        &#34;&#34;&#34;
        Gets the session associated with the token.

        Args:
            token (str): The session token.

        Returns:
            Session: The session object.
        &#34;&#34;&#34;

        return self.sessions.get(token)

    # close session with token
    def close_session(self, token):
        &#34;&#34;&#34;
        Closes the session with the specified token.

        Args:
            token (str): The session token.
        &#34;&#34;&#34;

        self.sessions.pop(token)

    # removal for sessions that have expired
    def remove_sessions(self):
        &#34;&#34;&#34;
        Removes sessions that have expired.
        Runs on the session cleanup thread.
        &#34;&#34;&#34;

        while True:
            remove_tokens = []

            try:
                # find sessions that have expired
                for token, session in self.sessions.items():
                    if session.seconds_alive() &gt; self.session_ttl:
                        remove_tokens.append(token)
            except RuntimeError as e:  # dictionary changed size during iteration
                return

            # remove expired sessions from dictionary
            for token in remove_tokens:
                print(f&#34;Deleted session with token={token}&#34;)
                self.sessions.pop(token)

            time.sleep(5)


# Server which works with the Communication Protocol
class CommunicationProtocolServer(SessionServer):
    &#34;&#34;&#34;
    Server which works with the Communication Protocol.

    Attributes:
        method_handlers (dict): Dictionary with method names as keys and functions to handle methods as values.
    &#34;&#34;&#34;

    def __init__(self, host, port, session_ttl, with_ssl):
        &#34;&#34;&#34;
        Constructor:
             Initializes the CommunicationProtocolServer instance.

             Args:
                 host (str): The host to bind the server to.
                 port (int): The port to bind the server to.
                 session_ttl (int): Time-to-live for a session in seconds.
                 with_ssl (bool): Whether to use SSL for secure connections.
         &#34;&#34;&#34;

        super().__init__(host, port, 8, session_ttl, with_ssl)

        self.handlers.append(self.parse_message)
        self.handlers.append(self.session_generator)
        self.handlers.append(self.method_handler)

        self.method_handlers = dict()  # key is method name, value is function to handle method

    # if request with Method=method is received, method_function will be called
    # method_function gets req, res and session object relevant to req session token
    # res is changed in method_function
    def handle_method(self, method, method_function):
        &#34;&#34;&#34;
        Adds the method_function to the method_handlers dictionary, with method as the key.
        If a request with Method=method is received, method_function will be called.

         Args:
             method (str): The method name.
             method_function (function): The function to handle the method.
         &#34;&#34;&#34;

        self.method_handlers[method] = method_function

    def receive_message(self, client_socket, client_address):
        &#34;&#34;&#34;
         Receives a full communication protocol byte message from the client.
         The receiving is done using the header_length and the content length.
         Returns the fully received communication protocol byte message for the parse message handler.

         Args:
             client_socket (socket.socket): The client socket.
             client_address (tuple): The client address.

         Returns:
             bytes: The complete communication protocol byte message.

         Raises:
             CommunicationProtocolException: If the message does not start with &#39;req&#39; or &#39;res&#39;.
         &#34;&#34;&#34;

        req_res = client_socket.recv(3)

        if req_res != &#34;req&#34;.encode() and req_res != &#34;res&#34;.encode():
            data = client_socket.recv(1)
            while data != &#34;&#34;:
                req_res += data
                data = client_socket.recv(1)
            raise CommunicationProtocolException(req_res, &#34;Message does not start with res or req&#34;)

        # receive headers
        header_length_bytes = client_socket.recv(6)[1:5]
        header_length = int.from_bytes(header_length_bytes, &#34;little&#34;)
        headers = client_socket.recv(header_length-9)

        # get Content-Length header to find length of body
        headers_list = headers.decode()
        headers_list = headers_list.split(&#34;:&#34;)
        headers_list.pop(-1)
        regular_expression = re.compile(r&#34;Content-Length=[0-9]+&#34;)
        content_length_header = list(filter(regular_expression.match, headers_list))[0]
        content_length = content_length_header.split(&#34;=&#34;)[1]
        content_length = int(content_length)

        # receive body
        body = client_socket.recv(content_length)

        # return complete byte message
        return req_res + &#34;:&#34;.encode() + header_length_bytes + &#34;:&#34;.encode() + headers + body

    # turn byte message into CommunicationProtocol object for next handler
    def parse_message(self, client_socket, client_address, message):
        &#34;&#34;&#34;
        Turns full communication protocol byte message into CommunicationProtocol object for the next handler.

        Args:
            client_socket (socket.socket): The client socket.
            client_address (tuple): The client address.
            message (bytes): The byte message.

        Returns:
            CommunicationProtocol: The parsed communication protocol message.
        &#34;&#34;&#34;

        return CommunicationProtocol.from_bytes(message)

    def session_generator(self, client_socket, client_address, req):
        session_value = req.get_header_value(&#34;Session&#34;)

        # create new session for use with client
        if session_value == &#34;*&#34;:
            session_token = self.create_session()
            req.set_header_value(&#34;Session&#34;, session_token)

        return req

    # creates response to specific method and sends it to client
    def method_handler(self, client_socket, client_address, req):
        &#34;&#34;&#34;
        Calls specific method handler function based on client requested method.
        Method is called with req object, new res object and session object.
        Res object is filled up by method handler function and is then sent to client.

        Args:
            client_socket (socket.socket): The client socket.
            client_address (tuple): The client address.
            req (CommunicationProtocol): The request message.

        Returns:
            tuple: The request and response messages for possible extra handling.
        &#34;&#34;&#34;

        # response object. Changed in method handler.
        res = CommunicationProtocol(&#34;res&#34;, dict(), None)

        # get session object using req session token
        session = None
        session_token = req.get_header_value(&#34;Session&#34;)
        if session_token[0] == &#34;~&#34;:
            session_token = session_token[1:]
        if session_token != &#34;-&#34;:
            session = self.get_session(session_token)

        # set session token in response
        res.set_header_value(&#34;Session&#34;, session_token)

        # call handler to method
        method = req.get_header_value(&#34;Method&#34;)
        self.method_handlers[method](req, res, session)

        # send response to client
        client_socket.send(res.to_bytes())

        # close session if requested to
        if req.get_header_value(&#34;Session&#34;)[0] == &#34;~&#34;:
            self.close_session(session_token)

        # return req and res for possible extra handles
        return req, res</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Server.CommunicationProtocolServer"><code class="flex name class">
<span>class <span class="ident">CommunicationProtocolServer</span></span>
<span>(</span><span>host, port, session_ttl, with_ssl)</span>
</code></dt>
<dd>
<div class="desc"><p>Server which works with the Communication Protocol.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>method_handlers</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with method names as keys and functions to handle methods as values.</dd>
</dl>
<h2 id="constructor">Constructor</h2>
<p>Initializes the CommunicationProtocolServer instance.</p>
<p>Args:
host (str): The host to bind the server to.
port (int): The port to bind the server to.
session_ttl (int): Time-to-live for a session in seconds.
with_ssl (bool): Whether to use SSL for secure connections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommunicationProtocolServer(SessionServer):
    &#34;&#34;&#34;
    Server which works with the Communication Protocol.

    Attributes:
        method_handlers (dict): Dictionary with method names as keys and functions to handle methods as values.
    &#34;&#34;&#34;

    def __init__(self, host, port, session_ttl, with_ssl):
        &#34;&#34;&#34;
        Constructor:
             Initializes the CommunicationProtocolServer instance.

             Args:
                 host (str): The host to bind the server to.
                 port (int): The port to bind the server to.
                 session_ttl (int): Time-to-live for a session in seconds.
                 with_ssl (bool): Whether to use SSL for secure connections.
         &#34;&#34;&#34;

        super().__init__(host, port, 8, session_ttl, with_ssl)

        self.handlers.append(self.parse_message)
        self.handlers.append(self.session_generator)
        self.handlers.append(self.method_handler)

        self.method_handlers = dict()  # key is method name, value is function to handle method

    # if request with Method=method is received, method_function will be called
    # method_function gets req, res and session object relevant to req session token
    # res is changed in method_function
    def handle_method(self, method, method_function):
        &#34;&#34;&#34;
        Adds the method_function to the method_handlers dictionary, with method as the key.
        If a request with Method=method is received, method_function will be called.

         Args:
             method (str): The method name.
             method_function (function): The function to handle the method.
         &#34;&#34;&#34;

        self.method_handlers[method] = method_function

    def receive_message(self, client_socket, client_address):
        &#34;&#34;&#34;
         Receives a full communication protocol byte message from the client.
         The receiving is done using the header_length and the content length.
         Returns the fully received communication protocol byte message for the parse message handler.

         Args:
             client_socket (socket.socket): The client socket.
             client_address (tuple): The client address.

         Returns:
             bytes: The complete communication protocol byte message.

         Raises:
             CommunicationProtocolException: If the message does not start with &#39;req&#39; or &#39;res&#39;.
         &#34;&#34;&#34;

        req_res = client_socket.recv(3)

        if req_res != &#34;req&#34;.encode() and req_res != &#34;res&#34;.encode():
            data = client_socket.recv(1)
            while data != &#34;&#34;:
                req_res += data
                data = client_socket.recv(1)
            raise CommunicationProtocolException(req_res, &#34;Message does not start with res or req&#34;)

        # receive headers
        header_length_bytes = client_socket.recv(6)[1:5]
        header_length = int.from_bytes(header_length_bytes, &#34;little&#34;)
        headers = client_socket.recv(header_length-9)

        # get Content-Length header to find length of body
        headers_list = headers.decode()
        headers_list = headers_list.split(&#34;:&#34;)
        headers_list.pop(-1)
        regular_expression = re.compile(r&#34;Content-Length=[0-9]+&#34;)
        content_length_header = list(filter(regular_expression.match, headers_list))[0]
        content_length = content_length_header.split(&#34;=&#34;)[1]
        content_length = int(content_length)

        # receive body
        body = client_socket.recv(content_length)

        # return complete byte message
        return req_res + &#34;:&#34;.encode() + header_length_bytes + &#34;:&#34;.encode() + headers + body

    # turn byte message into CommunicationProtocol object for next handler
    def parse_message(self, client_socket, client_address, message):
        &#34;&#34;&#34;
        Turns full communication protocol byte message into CommunicationProtocol object for the next handler.

        Args:
            client_socket (socket.socket): The client socket.
            client_address (tuple): The client address.
            message (bytes): The byte message.

        Returns:
            CommunicationProtocol: The parsed communication protocol message.
        &#34;&#34;&#34;

        return CommunicationProtocol.from_bytes(message)

    def session_generator(self, client_socket, client_address, req):
        session_value = req.get_header_value(&#34;Session&#34;)

        # create new session for use with client
        if session_value == &#34;*&#34;:
            session_token = self.create_session()
            req.set_header_value(&#34;Session&#34;, session_token)

        return req

    # creates response to specific method and sends it to client
    def method_handler(self, client_socket, client_address, req):
        &#34;&#34;&#34;
        Calls specific method handler function based on client requested method.
        Method is called with req object, new res object and session object.
        Res object is filled up by method handler function and is then sent to client.

        Args:
            client_socket (socket.socket): The client socket.
            client_address (tuple): The client address.
            req (CommunicationProtocol): The request message.

        Returns:
            tuple: The request and response messages for possible extra handling.
        &#34;&#34;&#34;

        # response object. Changed in method handler.
        res = CommunicationProtocol(&#34;res&#34;, dict(), None)

        # get session object using req session token
        session = None
        session_token = req.get_header_value(&#34;Session&#34;)
        if session_token[0] == &#34;~&#34;:
            session_token = session_token[1:]
        if session_token != &#34;-&#34;:
            session = self.get_session(session_token)

        # set session token in response
        res.set_header_value(&#34;Session&#34;, session_token)

        # call handler to method
        method = req.get_header_value(&#34;Method&#34;)
        self.method_handlers[method](req, res, session)

        # send response to client
        client_socket.send(res.to_bytes())

        # close session if requested to
        if req.get_header_value(&#34;Session&#34;)[0] == &#34;~&#34;:
            self.close_session(session_token)

        # return req and res for possible extra handles
        return req, res</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Server.SessionServer" href="#Server.SessionServer">SessionServer</a></li>
<li><a title="Server.Server" href="#Server.Server">Server</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Server.CommunicationProtocolServer.handle_method"><code class="name flex">
<span>def <span class="ident">handle_method</span></span>(<span>self, method, method_function)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the method_function to the method_handlers dictionary, with method as the key.
If a request with Method=method is received, method_function will be called.</p>
<p>Args:
method (str): The method name.
method_function (function): The function to handle the method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_method(self, method, method_function):
    &#34;&#34;&#34;
    Adds the method_function to the method_handlers dictionary, with method as the key.
    If a request with Method=method is received, method_function will be called.

     Args:
         method (str): The method name.
         method_function (function): The function to handle the method.
     &#34;&#34;&#34;

    self.method_handlers[method] = method_function</code></pre>
</details>
</dd>
<dt id="Server.CommunicationProtocolServer.method_handler"><code class="name flex">
<span>def <span class="ident">method_handler</span></span>(<span>self, client_socket, client_address, req)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls specific method handler function based on client requested method.
Method is called with req object, new res object and session object.
Res object is filled up by method handler function and is then sent to client.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client_socket</code></strong> :&ensp;<code>socket.socket</code></dt>
<dd>The client socket.</dd>
<dt><strong><code>client_address</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The client address.</dd>
<dt><strong><code>req</code></strong> :&ensp;<code>CommunicationProtocol</code></dt>
<dd>The request message.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>The request and response messages for possible extra handling.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_handler(self, client_socket, client_address, req):
    &#34;&#34;&#34;
    Calls specific method handler function based on client requested method.
    Method is called with req object, new res object and session object.
    Res object is filled up by method handler function and is then sent to client.

    Args:
        client_socket (socket.socket): The client socket.
        client_address (tuple): The client address.
        req (CommunicationProtocol): The request message.

    Returns:
        tuple: The request and response messages for possible extra handling.
    &#34;&#34;&#34;

    # response object. Changed in method handler.
    res = CommunicationProtocol(&#34;res&#34;, dict(), None)

    # get session object using req session token
    session = None
    session_token = req.get_header_value(&#34;Session&#34;)
    if session_token[0] == &#34;~&#34;:
        session_token = session_token[1:]
    if session_token != &#34;-&#34;:
        session = self.get_session(session_token)

    # set session token in response
    res.set_header_value(&#34;Session&#34;, session_token)

    # call handler to method
    method = req.get_header_value(&#34;Method&#34;)
    self.method_handlers[method](req, res, session)

    # send response to client
    client_socket.send(res.to_bytes())

    # close session if requested to
    if req.get_header_value(&#34;Session&#34;)[0] == &#34;~&#34;:
        self.close_session(session_token)

    # return req and res for possible extra handles
    return req, res</code></pre>
</details>
</dd>
<dt id="Server.CommunicationProtocolServer.parse_message"><code class="name flex">
<span>def <span class="ident">parse_message</span></span>(<span>self, client_socket, client_address, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Turns full communication protocol byte message into CommunicationProtocol object for the next handler.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client_socket</code></strong> :&ensp;<code>socket.socket</code></dt>
<dd>The client socket.</dd>
<dt><strong><code>client_address</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The client address.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The byte message.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CommunicationProtocol</code></dt>
<dd>The parsed communication protocol message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_message(self, client_socket, client_address, message):
    &#34;&#34;&#34;
    Turns full communication protocol byte message into CommunicationProtocol object for the next handler.

    Args:
        client_socket (socket.socket): The client socket.
        client_address (tuple): The client address.
        message (bytes): The byte message.

    Returns:
        CommunicationProtocol: The parsed communication protocol message.
    &#34;&#34;&#34;

    return CommunicationProtocol.from_bytes(message)</code></pre>
</details>
</dd>
<dt id="Server.CommunicationProtocolServer.receive_message"><code class="name flex">
<span>def <span class="ident">receive_message</span></span>(<span>self, client_socket, client_address)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives a full communication protocol byte message from the client.
The receiving is done using the header_length and the content length.
Returns the fully received communication protocol byte message for the parse message handler.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client_socket</code></strong> :&ensp;<code>socket.socket</code></dt>
<dd>The client socket.</dd>
<dt><strong><code>client_address</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The client address.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The complete communication protocol byte message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>CommunicationProtocolException</code></dt>
<dd>If the message does not start with 'req' or 'res'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def receive_message(self, client_socket, client_address):
    &#34;&#34;&#34;
     Receives a full communication protocol byte message from the client.
     The receiving is done using the header_length and the content length.
     Returns the fully received communication protocol byte message for the parse message handler.

     Args:
         client_socket (socket.socket): The client socket.
         client_address (tuple): The client address.

     Returns:
         bytes: The complete communication protocol byte message.

     Raises:
         CommunicationProtocolException: If the message does not start with &#39;req&#39; or &#39;res&#39;.
     &#34;&#34;&#34;

    req_res = client_socket.recv(3)

    if req_res != &#34;req&#34;.encode() and req_res != &#34;res&#34;.encode():
        data = client_socket.recv(1)
        while data != &#34;&#34;:
            req_res += data
            data = client_socket.recv(1)
        raise CommunicationProtocolException(req_res, &#34;Message does not start with res or req&#34;)

    # receive headers
    header_length_bytes = client_socket.recv(6)[1:5]
    header_length = int.from_bytes(header_length_bytes, &#34;little&#34;)
    headers = client_socket.recv(header_length-9)

    # get Content-Length header to find length of body
    headers_list = headers.decode()
    headers_list = headers_list.split(&#34;:&#34;)
    headers_list.pop(-1)
    regular_expression = re.compile(r&#34;Content-Length=[0-9]+&#34;)
    content_length_header = list(filter(regular_expression.match, headers_list))[0]
    content_length = content_length_header.split(&#34;=&#34;)[1]
    content_length = int(content_length)

    # receive body
    body = client_socket.recv(content_length)

    # return complete byte message
    return req_res + &#34;:&#34;.encode() + header_length_bytes + &#34;:&#34;.encode() + headers + body</code></pre>
</details>
</dd>
<dt id="Server.CommunicationProtocolServer.session_generator"><code class="name flex">
<span>def <span class="ident">session_generator</span></span>(<span>self, client_socket, client_address, req)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def session_generator(self, client_socket, client_address, req):
    session_value = req.get_header_value(&#34;Session&#34;)

    # create new session for use with client
    if session_value == &#34;*&#34;:
        session_token = self.create_session()
        req.set_header_value(&#34;Session&#34;, session_token)

    return req</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Server.SessionServer" href="#Server.SessionServer">SessionServer</a></b></code>:
<ul class="hlist">
<li><code><a title="Server.SessionServer.add_handler" href="#Server.Server.add_handler">add_handler</a></code></li>
<li><code><a title="Server.SessionServer.close_client" href="#Server.Server.close_client">close_client</a></code></li>
<li><code><a title="Server.SessionServer.close_session" href="#Server.SessionServer.close_session">close_session</a></code></li>
<li><code><a title="Server.SessionServer.create_session" href="#Server.SessionServer.create_session">create_session</a></code></li>
<li><code><a title="Server.SessionServer.generate_session_token" href="#Server.SessionServer.generate_session_token">generate_session_token</a></code></li>
<li><code><a title="Server.SessionServer.get_session" href="#Server.SessionServer.get_session">get_session</a></code></li>
<li><code><a title="Server.SessionServer.handle_client" href="#Server.Server.handle_client">handle_client</a></code></li>
<li><code><a title="Server.SessionServer.remove_handler" href="#Server.Server.remove_handler">remove_handler</a></code></li>
<li><code><a title="Server.SessionServer.remove_sessions" href="#Server.SessionServer.remove_sessions">remove_sessions</a></code></li>
<li><code><a title="Server.SessionServer.serve_forever" href="#Server.SessionServer.serve_forever">serve_forever</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Server.Server"><code class="flex name class">
<span>class <span class="ident">Server</span></span>
<span>(</span><span>host, port, with_ssl)</span>
</code></dt>
<dd>
<div class="desc"><p>TCP Socket Server which binds to a given host and port.
Each client connection is handled in a different thread.
Client connections go through different handler functions.
Handler functions are called in added order. The result of one handler goes to the next.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>The host to bind the server to.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>The port to bind the server to.</dd>
<dt><strong><code>ssl_context</code></strong> :&ensp;<code>ssl.SSLContext</code></dt>
<dd>The SSL context for secure connections.</dd>
<dt><strong><code>server_socket</code></strong> :&ensp;<code>socket.socket</code></dt>
<dd>The server socket.</dd>
<dt><strong><code>handlers</code></strong> :&ensp;<code>list</code></dt>
<dd>List of handler functions to process client connections.</dd>
</dl>
<h2 id="constructor">Constructor</h2>
<p>Initializes the Server instance.</p>
<p>Args:
host (str): The host to bind the server to.
port (int): The port to bind the server to.
with_ssl (bool): Whether to use SSL for secure connections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Server:
    &#34;&#34;&#34;
    TCP Socket Server which binds to a given host and port.
    Each client connection is handled in a different thread.
    Client connections go through different handler functions.
    Handler functions are called in added order. The result of one handler goes to the next.

    Attributes:
        host (str): The host to bind the server to.
        port (int): The port to bind the server to.
        ssl_context (ssl.SSLContext): The SSL context for secure connections.
        server_socket (socket.socket): The server socket.
        handlers (list): List of handler functions to process client connections.
    &#34;&#34;&#34;

    def __init__(self, host, port, with_ssl):
        &#34;&#34;&#34;
        Constructor:
            Initializes the Server instance.

            Args:
                host (str): The host to bind the server to.
                port (int): The port to bind the server to.
                with_ssl (bool): Whether to use SSL for secure connections.
        &#34;&#34;&#34;

        self.port = port
        self.host = host

        self.ssl_context = None
        if with_ssl:
            self.ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
            self.ssl_context.load_cert_chain(certfile=r&#34;SSL/cert.pem&#34;, keyfile=r&#34;SSL/key.pem&#34;)

        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        self.handlers = []  # each handler is a function which takes client_socket, client_address, prev_result

    # add handler function to deal with client connection
    def add_handler(self, handler):
        &#34;&#34;&#34;
        Adds a handler function to process client connections.

        Args:
            handler (function): The handler function to add.
        &#34;&#34;&#34;

        self.handlers.append(handler)

    # remove handler function
    def remove_handler(self, handler):
        &#34;&#34;&#34;
        Removes a handler function.

        Args:
            handler (function): The handler function to remove.
        &#34;&#34;&#34;

        self.handlers.remove(handler)

    # receive message from client. Default receives 1024 bytes from client socket.
    def receive_message(self, client_socket, client_address):
        &#34;&#34;&#34;
        Receives a message from the client. Default receives 1024 bytes from client socket.

        Args:
            client_socket (socket.socket): The client socket.
            client_address (tuple): The client address.

        Returns:
            bytes: The received message.
        &#34;&#34;&#34;

        return client_socket.recv(1024)

    # what to do on client closing. Default just closes socket.
    def close_client(self, client_socket, client_address):
        &#34;&#34;&#34;
        Handles client closing. Default just closes the socket.

        Args:
            client_socket (socket.socket): The client socket.
            client_address (tuple): The client address.
        &#34;&#34;&#34;

        client_socket.close()

    # handle connection from client. message goes through all handler functions
    def handle_client(self, client_socket, client_address):
        &#34;&#34;&#34;
        Handles connection from the client.
        The message is received using receive_message function.
        The message then goes through all handler functions.
        At the end close_client function is called.

        Args:
            client_socket (socket.socket): The client socket.
            client_address (tuple): The client address.
        &#34;&#34;&#34;

        message = self.receive_message(client_socket, client_address)

        prev_result = message
        for handler in self.handlers:
            prev_result = handler(client_socket, client_address, prev_result)

        self.close_client(client_socket, client_address)

    # turn server on to forever serve
    def serve_forever(self):
        &#34;&#34;&#34;
        Turns the server on to serve forever.
        &#34;&#34;&#34;

        print(f&#34;Starting Server on host={self.host}, port={self.port}&#34;)
        self.server_socket.bind((self.host, self.port))

        server_socket = self.server_socket
        if self.ssl_context is not None:
            server_socket = self.ssl_context.wrap_socket(server_socket, server_side=True)

        while True:
            server_socket.listen()
            client_socket, client_address = server_socket.accept()
            print(f&#34;Received Connection from {client_address}&#34;)
            client_thread = Thread(target=self.handle_client, args=(client_socket, client_address))
            client_thread.start()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="Server.SessionServer" href="#Server.SessionServer">SessionServer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Server.Server.add_handler"><code class="name flex">
<span>def <span class="ident">add_handler</span></span>(<span>self, handler)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a handler function to process client connections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>handler</code></strong> :&ensp;<code>function</code></dt>
<dd>The handler function to add.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_handler(self, handler):
    &#34;&#34;&#34;
    Adds a handler function to process client connections.

    Args:
        handler (function): The handler function to add.
    &#34;&#34;&#34;

    self.handlers.append(handler)</code></pre>
</details>
</dd>
<dt id="Server.Server.close_client"><code class="name flex">
<span>def <span class="ident">close_client</span></span>(<span>self, client_socket, client_address)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles client closing. Default just closes the socket.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client_socket</code></strong> :&ensp;<code>socket.socket</code></dt>
<dd>The client socket.</dd>
<dt><strong><code>client_address</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The client address.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_client(self, client_socket, client_address):
    &#34;&#34;&#34;
    Handles client closing. Default just closes the socket.

    Args:
        client_socket (socket.socket): The client socket.
        client_address (tuple): The client address.
    &#34;&#34;&#34;

    client_socket.close()</code></pre>
</details>
</dd>
<dt id="Server.Server.handle_client"><code class="name flex">
<span>def <span class="ident">handle_client</span></span>(<span>self, client_socket, client_address)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles connection from the client.
The message is received using receive_message function.
The message then goes through all handler functions.
At the end close_client function is called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client_socket</code></strong> :&ensp;<code>socket.socket</code></dt>
<dd>The client socket.</dd>
<dt><strong><code>client_address</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The client address.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_client(self, client_socket, client_address):
    &#34;&#34;&#34;
    Handles connection from the client.
    The message is received using receive_message function.
    The message then goes through all handler functions.
    At the end close_client function is called.

    Args:
        client_socket (socket.socket): The client socket.
        client_address (tuple): The client address.
    &#34;&#34;&#34;

    message = self.receive_message(client_socket, client_address)

    prev_result = message
    for handler in self.handlers:
        prev_result = handler(client_socket, client_address, prev_result)

    self.close_client(client_socket, client_address)</code></pre>
</details>
</dd>
<dt id="Server.Server.receive_message"><code class="name flex">
<span>def <span class="ident">receive_message</span></span>(<span>self, client_socket, client_address)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives a message from the client. Default receives 1024 bytes from client socket.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client_socket</code></strong> :&ensp;<code>socket.socket</code></dt>
<dd>The client socket.</dd>
<dt><strong><code>client_address</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The client address.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The received message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def receive_message(self, client_socket, client_address):
    &#34;&#34;&#34;
    Receives a message from the client. Default receives 1024 bytes from client socket.

    Args:
        client_socket (socket.socket): The client socket.
        client_address (tuple): The client address.

    Returns:
        bytes: The received message.
    &#34;&#34;&#34;

    return client_socket.recv(1024)</code></pre>
</details>
</dd>
<dt id="Server.Server.remove_handler"><code class="name flex">
<span>def <span class="ident">remove_handler</span></span>(<span>self, handler)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a handler function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>handler</code></strong> :&ensp;<code>function</code></dt>
<dd>The handler function to remove.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_handler(self, handler):
    &#34;&#34;&#34;
    Removes a handler function.

    Args:
        handler (function): The handler function to remove.
    &#34;&#34;&#34;

    self.handlers.remove(handler)</code></pre>
</details>
</dd>
<dt id="Server.Server.serve_forever"><code class="name flex">
<span>def <span class="ident">serve_forever</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Turns the server on to serve forever.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serve_forever(self):
    &#34;&#34;&#34;
    Turns the server on to serve forever.
    &#34;&#34;&#34;

    print(f&#34;Starting Server on host={self.host}, port={self.port}&#34;)
    self.server_socket.bind((self.host, self.port))

    server_socket = self.server_socket
    if self.ssl_context is not None:
        server_socket = self.ssl_context.wrap_socket(server_socket, server_side=True)

    while True:
        server_socket.listen()
        client_socket, client_address = server_socket.accept()
        print(f&#34;Received Connection from {client_address}&#34;)
        client_thread = Thread(target=self.handle_client, args=(client_socket, client_address))
        client_thread.start()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Server.SessionServer"><code class="flex name class">
<span>class <span class="ident">SessionServer</span></span>
<span>(</span><span>host, port, session_token_length, session_ttl, with_ssl)</span>
</code></dt>
<dd>
<div class="desc"><p>Server with storing session capabilities.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>sessions</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary storing sessions with session tokens as keys and session objects as values.</dd>
<dt><strong><code>session_token_length</code></strong> :&ensp;<code>int</code></dt>
<dd>Length of the session token.</dd>
<dt><strong><code>session_ttl</code></strong> :&ensp;<code>int</code></dt>
<dd>Time-to-live for a session in seconds.</dd>
<dt><strong><code>session_cleanup_thread</code></strong> :&ensp;<code>threading.Thread</code></dt>
<dd>Thread to remove expired sessions.</dd>
</dl>
<h2 id="constructor">Constructor</h2>
<p>Initializes the SessionServer instance.</p>
<p>Args:
host (str): The host to bind the server to.
port (int): The port to bind the server to.
session_token_length (int): Length of the session token.
session_ttl (int): Time-to-live for a session in seconds.
with_ssl (bool): Whether to use SSL for secure connections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SessionServer(Server):
    &#34;&#34;&#34;
    Server with storing session capabilities.

    Attributes:
        sessions (dict): Dictionary storing sessions with session tokens as keys and session objects as values.
        session_token_length (int): Length of the session token.
        session_ttl (int): Time-to-live for a session in seconds.
        session_cleanup_thread (threading.Thread): Thread to remove expired sessions.
    &#34;&#34;&#34;

    def __init__(self, host, port, session_token_length, session_ttl, with_ssl):
        &#34;&#34;&#34;
        Constructor:
             Initializes the SessionServer instance.

             Args:
                 host (str): The host to bind the server to.
                 port (int): The port to bind the server to.
                 session_token_length (int): Length of the session token.
                 session_ttl (int): Time-to-live for a session in seconds.
                 with_ssl (bool): Whether to use SSL for secure connections.
        &#34;&#34;&#34;

        super().__init__(host, port, with_ssl)

        self.sessions = dict()  # key is session token, value is session object
        self.session_token_length = session_token_length

        self.session_ttl = session_ttl  # number of seconds that session is allowed to live
        self.session_cleanup_thread = Thread(target=self.remove_sessions)

    def serve_forever(self):
        &#34;&#34;&#34;
        Turns the server on to serve forever and starts the session cleanup thread.
        &#34;&#34;&#34;

        self.session_cleanup_thread.start()
        super().serve_forever()

    # generate unique token for new session
    def generate_session_token(self, length):
        &#34;&#34;&#34;
        Generates a unique token for a new session.

        Args:
            length (int): Length of the session token.

        Returns:
            str: The generated session token.
        &#34;&#34;&#34;

        characters = string.ascii_lowercase + string.ascii_uppercase + string.digits
        token = &#34;&#34;

        while token in self.sessions or token == &#34;&#34;:
            token = &#34;&#34;
            for i in range(length):
                token += characters[randint(0, len(characters)-1)]

        return token

    # create a session and return its token
    def create_session(self):
        &#34;&#34;&#34;
         Creates a session and returns its token.

         Returns:
             str: The session token.
         &#34;&#34;&#34;

        token = self.generate_session_token(self.session_token_length)
        self.sessions[token] = Session()

        return token

    # get session associated with token
    def get_session(self, token):
        &#34;&#34;&#34;
        Gets the session associated with the token.

        Args:
            token (str): The session token.

        Returns:
            Session: The session object.
        &#34;&#34;&#34;

        return self.sessions.get(token)

    # close session with token
    def close_session(self, token):
        &#34;&#34;&#34;
        Closes the session with the specified token.

        Args:
            token (str): The session token.
        &#34;&#34;&#34;

        self.sessions.pop(token)

    # removal for sessions that have expired
    def remove_sessions(self):
        &#34;&#34;&#34;
        Removes sessions that have expired.
        Runs on the session cleanup thread.
        &#34;&#34;&#34;

        while True:
            remove_tokens = []

            try:
                # find sessions that have expired
                for token, session in self.sessions.items():
                    if session.seconds_alive() &gt; self.session_ttl:
                        remove_tokens.append(token)
            except RuntimeError as e:  # dictionary changed size during iteration
                return

            # remove expired sessions from dictionary
            for token in remove_tokens:
                print(f&#34;Deleted session with token={token}&#34;)
                self.sessions.pop(token)

            time.sleep(5)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Server.Server" href="#Server.Server">Server</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="Server.CommunicationProtocolServer" href="#Server.CommunicationProtocolServer">CommunicationProtocolServer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Server.SessionServer.close_session"><code class="name flex">
<span>def <span class="ident">close_session</span></span>(<span>self, token)</span>
</code></dt>
<dd>
<div class="desc"><p>Closes the session with the specified token.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code>str</code></dt>
<dd>The session token.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_session(self, token):
    &#34;&#34;&#34;
    Closes the session with the specified token.

    Args:
        token (str): The session token.
    &#34;&#34;&#34;

    self.sessions.pop(token)</code></pre>
</details>
</dd>
<dt id="Server.SessionServer.create_session"><code class="name flex">
<span>def <span class="ident">create_session</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a session and returns its token.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The session token.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_session(self):
    &#34;&#34;&#34;
     Creates a session and returns its token.

     Returns:
         str: The session token.
     &#34;&#34;&#34;

    token = self.generate_session_token(self.session_token_length)
    self.sessions[token] = Session()

    return token</code></pre>
</details>
</dd>
<dt id="Server.SessionServer.generate_session_token"><code class="name flex">
<span>def <span class="ident">generate_session_token</span></span>(<span>self, length)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a unique token for a new session.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>Length of the session token.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The generated session token.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_session_token(self, length):
    &#34;&#34;&#34;
    Generates a unique token for a new session.

    Args:
        length (int): Length of the session token.

    Returns:
        str: The generated session token.
    &#34;&#34;&#34;

    characters = string.ascii_lowercase + string.ascii_uppercase + string.digits
    token = &#34;&#34;

    while token in self.sessions or token == &#34;&#34;:
        token = &#34;&#34;
        for i in range(length):
            token += characters[randint(0, len(characters)-1)]

    return token</code></pre>
</details>
</dd>
<dt id="Server.SessionServer.get_session"><code class="name flex">
<span>def <span class="ident">get_session</span></span>(<span>self, token)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the session associated with the token.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code>str</code></dt>
<dd>The session token.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Session</code></dt>
<dd>The session object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_session(self, token):
    &#34;&#34;&#34;
    Gets the session associated with the token.

    Args:
        token (str): The session token.

    Returns:
        Session: The session object.
    &#34;&#34;&#34;

    return self.sessions.get(token)</code></pre>
</details>
</dd>
<dt id="Server.SessionServer.remove_sessions"><code class="name flex">
<span>def <span class="ident">remove_sessions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes sessions that have expired.
Runs on the session cleanup thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_sessions(self):
    &#34;&#34;&#34;
    Removes sessions that have expired.
    Runs on the session cleanup thread.
    &#34;&#34;&#34;

    while True:
        remove_tokens = []

        try:
            # find sessions that have expired
            for token, session in self.sessions.items():
                if session.seconds_alive() &gt; self.session_ttl:
                    remove_tokens.append(token)
        except RuntimeError as e:  # dictionary changed size during iteration
            return

        # remove expired sessions from dictionary
        for token in remove_tokens:
            print(f&#34;Deleted session with token={token}&#34;)
            self.sessions.pop(token)

        time.sleep(5)</code></pre>
</details>
</dd>
<dt id="Server.SessionServer.serve_forever"><code class="name flex">
<span>def <span class="ident">serve_forever</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Turns the server on to serve forever and starts the session cleanup thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serve_forever(self):
    &#34;&#34;&#34;
    Turns the server on to serve forever and starts the session cleanup thread.
    &#34;&#34;&#34;

    self.session_cleanup_thread.start()
    super().serve_forever()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Server.Server" href="#Server.Server">Server</a></b></code>:
<ul class="hlist">
<li><code><a title="Server.Server.add_handler" href="#Server.Server.add_handler">add_handler</a></code></li>
<li><code><a title="Server.Server.close_client" href="#Server.Server.close_client">close_client</a></code></li>
<li><code><a title="Server.Server.handle_client" href="#Server.Server.handle_client">handle_client</a></code></li>
<li><code><a title="Server.Server.receive_message" href="#Server.Server.receive_message">receive_message</a></code></li>
<li><code><a title="Server.Server.remove_handler" href="#Server.Server.remove_handler">remove_handler</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Server.CommunicationProtocolServer" href="#Server.CommunicationProtocolServer">CommunicationProtocolServer</a></code></h4>
<ul class="">
<li><code><a title="Server.CommunicationProtocolServer.handle_method" href="#Server.CommunicationProtocolServer.handle_method">handle_method</a></code></li>
<li><code><a title="Server.CommunicationProtocolServer.method_handler" href="#Server.CommunicationProtocolServer.method_handler">method_handler</a></code></li>
<li><code><a title="Server.CommunicationProtocolServer.parse_message" href="#Server.CommunicationProtocolServer.parse_message">parse_message</a></code></li>
<li><code><a title="Server.CommunicationProtocolServer.receive_message" href="#Server.CommunicationProtocolServer.receive_message">receive_message</a></code></li>
<li><code><a title="Server.CommunicationProtocolServer.session_generator" href="#Server.CommunicationProtocolServer.session_generator">session_generator</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Server.Server" href="#Server.Server">Server</a></code></h4>
<ul class="two-column">
<li><code><a title="Server.Server.add_handler" href="#Server.Server.add_handler">add_handler</a></code></li>
<li><code><a title="Server.Server.close_client" href="#Server.Server.close_client">close_client</a></code></li>
<li><code><a title="Server.Server.handle_client" href="#Server.Server.handle_client">handle_client</a></code></li>
<li><code><a title="Server.Server.receive_message" href="#Server.Server.receive_message">receive_message</a></code></li>
<li><code><a title="Server.Server.remove_handler" href="#Server.Server.remove_handler">remove_handler</a></code></li>
<li><code><a title="Server.Server.serve_forever" href="#Server.Server.serve_forever">serve_forever</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Server.SessionServer" href="#Server.SessionServer">SessionServer</a></code></h4>
<ul class="">
<li><code><a title="Server.SessionServer.close_session" href="#Server.SessionServer.close_session">close_session</a></code></li>
<li><code><a title="Server.SessionServer.create_session" href="#Server.SessionServer.create_session">create_session</a></code></li>
<li><code><a title="Server.SessionServer.generate_session_token" href="#Server.SessionServer.generate_session_token">generate_session_token</a></code></li>
<li><code><a title="Server.SessionServer.get_session" href="#Server.SessionServer.get_session">get_session</a></code></li>
<li><code><a title="Server.SessionServer.remove_sessions" href="#Server.SessionServer.remove_sessions">remove_sessions</a></code></li>
<li><code><a title="Server.SessionServer.serve_forever" href="#Server.SessionServer.serve_forever">serve_forever</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>